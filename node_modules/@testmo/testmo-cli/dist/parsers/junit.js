"use strict";
/*
 * Copyright (c) Testmo GmbH (Berlin, Germany)
 * All rights reserved.
 * contact@testmo.com - www.testmo.com
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUnitParser = void 0;
var parser_1 = require("../core/parser");
var fast_xml_parser_1 = require("fast-xml-parser");
var validator_1 = __importDefault(require("validator"));
var path_1 = __importDefault(require("path"));
var lodash_1 = __importDefault(require("lodash"));
var JUnitParser = /** @class */ (function (_super) {
    __extends(JUnitParser, _super);
    function JUnitParser() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.name = 'JUnit XML';
        return _this;
    }
    JUnitParser.prototype.detect = function (content, filename) {
        var extensions = [
            '.junit',
            '.log',
            '.report',
            '.reports',
            '.result',
            '.results',
            '.xml'
        ];
        var extension = path_1.default.extname(filename).toLowerCase();
        var isKnownExtension = false;
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
            var allowedExtension = extensions_1[_i];
            if (allowedExtension == extension) {
                isKnownExtension = true;
                break;
            }
        }
        if (!isKnownExtension) {
            return false;
        }
        // Some tools generate XML files without leading <?xml>, so we
        // allow different checks
        return /<\?xml.+<testsuite/s.test(content) || /<testsuite/s.test(content);
    };
    JUnitParser.prototype.parse = function (content) {
        var xmlParser = new fast_xml_parser_1.XMLParser({
            // Similar to arrayMode: 'strict' previously (with the exception of '#text')
            isArray: function (name, jpath, isLeafNode, isAttribute) {
                return true;
            },
            ignoreAttributes: false,
            parseAttributeValue: false,
            parseTagValue: false
        });
        var xml = xmlParser.parse(content, true);
        var results = {
            tests: [],
            attachments: [],
            fields: []
        };
        var resources = this.collectResources(xml);
        if (resources) {
            results.attachments = resources.attachments;
            results.fields = resources.fields;
        }
        var elapsed = this.collectElapsed(xml);
        if (elapsed !== undefined) {
            results.elapsed = elapsed;
        }
        var tests = this.collectTests(xml);
        if (tests) {
            results.tests = tests;
        }
        return results;
    };
    JUnitParser.prototype.collectResources = function (xml) {
        if (!(xml instanceof Object)) {
            return;
        }
        var topElement = this.getTopElement(xml, function (element) {
            return ('properties' in element) ||
                ('system-out' in element) ||
                ('system-err' in element);
        });
        if (topElement === undefined) {
            return;
        }
        return this.getResourcesForElement(topElement);
    };
    JUnitParser.prototype.getTopElement = function (xml, evaluate) {
        var recursiveGetTopElement = function (element) {
            if (!(element instanceof Object)) {
                return;
            }
            if (evaluate(element)) {
                return element;
            }
            // Does this element have just a single testsuite or testsuites
            // child and not testcase elements?
            var testsuitesChildren = 0;
            var testsuiteChildren = 0;
            var testcaseChildren = 0;
            if ('testsuites' in element && Array.isArray(element.testsuites)) {
                testsuitesChildren = element.testsuites.length;
            }
            if ('testsuite' in element && Array.isArray(element.testsuite)) {
                testsuiteChildren = element.testsuite.length;
            }
            if ('testcase' in element && Array.isArray(element.testcase)) {
                testcaseChildren = element.testcase.length;
            }
            // We got a node with test cases, so any testsuite or testsuites childs
            // cannot be the top element anymore
            if (testcaseChildren > 0) {
                return;
            }
            if (testsuitesChildren == 1 && testsuiteChildren == 0) {
                return recursiveGetTopElement(element.testsuites[0]);
            }
            if (testsuitesChildren == 0 && testsuiteChildren == 1) {
                return recursiveGetTopElement(element.testsuite[0]);
            }
        };
        return recursiveGetTopElement(xml);
    };
    JUnitParser.prototype.collectElapsed = function (xml) {
        if (!(xml instanceof Object)) {
            return;
        }
        var topElement = this.getTopElement(xml, function (element) {
            return ('@_time' in element) || ('@_duration' in element);
        });
        if (topElement === undefined) {
            return;
        }
        if (this.hasNonEmptyAttribute(topElement, '@_time')) {
            var time = this.getTimeAttribute(topElement, '@_time');
            if (time !== undefined) {
                return time;
            }
        }
        if (this.hasNonEmptyAttribute(topElement, '@_duration')) {
            var duration = this.getTimeAttribute(topElement, '@_duration');
            if (duration !== undefined) {
                return duration;
            }
        }
    };
    JUnitParser.prototype.hasNonEmptyAttribute = function (element, attribute) {
        return (attribute in element) &&
            Array.isArray(element[attribute]) &&
            (element[attribute].length > 0) &&
            !validator_1.default.isEmpty(element[attribute][0]);
    };
    JUnitParser.prototype.getTimeAttribute = function (element, attribute) {
        var value = element[attribute][0].replace(/,/, '.');
        if (!validator_1.default.isNumeric(value)) {
            return;
        }
        var time = Number.parseFloat(value);
        if (Number.isNaN(time) || time < 0) {
            return;
        }
        // Convert to microseconds
        return Math.round(time * 1000000);
    };
    JUnitParser.prototype.collectTests = function (xml) {
        var _this = this;
        var getTestResultStatusField = function (element, status) {
            // We only add a new field if we get some useful information about
            // the status. E.g. for a simple <skipped/> element without content
            // and without attributes, we don't add a field.
            element = _this.convertTextElementToObject(element);
            if (!(element instanceof Object)) {
                // Empty tag
                return;
            }
            var meta = {};
            var text = '#text' in element ? element['#text'] : undefined;
            var value = text;
            // Use attribute for value priority: message > type
            for (var _i = 0, _a = ['message', 'type']; _i < _a.length; _i++) {
                var attribute = _a[_i];
                if (_this.hasNonEmptyAttribute(element, '@_' + attribute)) {
                    var attributeValue = element['@_' + attribute][0];
                    if (value === undefined) {
                        value = attributeValue;
                    }
                    else {
                        meta[attribute] = attributeValue;
                    }
                }
            }
            // We couldn't find any useful information
            if (value === undefined) {
                return;
            }
            return {
                source: 'status',
                type: 'console',
                name: lodash_1.default.startCase(status.toLowerCase()),
                value: value,
                isHighlight: true,
                meta: meta
            };
        };
        var applyTestAttributes = function (test, element) {
            if (_this.hasNonEmptyAttribute(element, '@_classname')) {
                test.folder = element['@_classname'][0];
            }
            else if (_this.hasNonEmptyAttribute(element, '@_class')) {
                test.folder = element['@_class'][0];
            }
            if (_this.hasNonEmptyAttribute(element, '@_time')) {
                var time = _this.getTimeAttribute(element, '@_time');
                if (time !== undefined) {
                    test.elapsed = time;
                }
            }
            if (test.elapsed === undefined &&
                _this.hasNonEmptyAttribute(element, '@_duration')) {
                var duration = _this.getTimeAttribute(element, '@_duration');
                if (duration !== undefined) {
                    test.elapsed = duration;
                }
            }
            if (_this.hasNonEmptyAttribute(element, '@_file')) {
                test.file = element['@_file'][0];
            }
            if (_this.hasNonEmptyAttribute(element, '@_line')) {
                var line = _this.getIntAttribute(element, '@_line');
                if (line !== undefined && line >= 0) {
                    test.line = line;
                }
            }
            if (_this.hasNonEmptyAttribute(element, '@_assertions')) {
                var assertions = _this.getIntAttribute(element, '@_assertions');
                if (assertions !== undefined && assertions >= 0) {
                    test.assertions = assertions;
                }
            }
        };
        var getTest = function (element) {
            var _a, _b, _c;
            if (!(element instanceof Object)) {
                // Empty test case
                return;
            }
            if (!_this.hasNonEmptyAttribute(element, '@_name')) {
                return;
            }
            var test = {
                key: element['@_name'][0],
                name: element['@_name'][0],
                status: 'passed',
                attachments: [],
                fields: [],
                steps: []
            };
            applyTestAttributes(test, element);
            // Test status priority: error > failure > skipped
            for (var _i = 0, _d = ['skipped', 'failure', 'error']; _i < _d.length; _i++) {
                var status_1 = _d[_i];
                if (status_1 in element) {
                    for (var _e = 0, _f = element[status_1]; _e < _f.length; _e++) {
                        var statusElement = _f[_e];
                        var field = getTestResultStatusField(statusElement, status_1);
                        if (field !== undefined) {
                            test.fields.push(field);
                        }
                    }
                    test.status = status_1;
                }
            }
            var resources = _this.getResourcesForElement(element);
            if (resources.attachments) {
                (_a = test.attachments).push.apply(_a, resources.attachments);
            }
            if (resources.fields) {
                (_b = test.fields).push.apply(_b, resources.fields);
            }
            if (resources.steps) {
                (_c = test.steps).push.apply(_c, resources.steps);
            }
            // Improve test key if possible
            if ('folder' in test) {
                test.key = "".concat(test.folder, ".").concat(test.name);
            }
            return test;
        };
        var getTestsForSuite = function (parentElement) {
            if (!(parentElement instanceof Object)) {
                return [];
            }
            var tests = [];
            if ('testsuite' in parentElement) {
                for (var _i = 0, _a = parentElement.testsuite; _i < _a.length; _i++) {
                    var testsuite = _a[_i];
                    tests.push.apply(tests, getTestsForSuite(testsuite));
                }
            }
            if ('testsuites' in parentElement) {
                for (var _b = 0, _c = parentElement.testsuites; _b < _c.length; _b++) {
                    var testsuites = _c[_b];
                    tests.push.apply(tests, getTestsForSuite(testsuites));
                }
            }
            if ('testcase' in parentElement) {
                for (var _d = 0, _e = parentElement.testcase; _d < _e.length; _d++) {
                    var testcase = _e[_d];
                    var test_1 = getTest(testcase);
                    if (test_1 !== undefined) {
                        tests.push(test_1);
                    }
                }
            }
            return tests;
        };
        return getTestsForSuite(xml);
    };
    JUnitParser.prototype.convertTextElementToObject = function (element) {
        if (typeof element === 'string' && !validator_1.default.isEmpty(element)) {
            return {
                '#text': element
            };
        }
        return element;
    };
    JUnitParser.prototype.getIntAttribute = function (element, attribute) {
        var value = element[attribute][0];
        if (!validator_1.default.isInt(value)) {
            return;
        }
        var intValue = Number.parseInt(value, 10);
        if (Number.isNaN(intValue)) {
            return;
        }
        return intValue;
    };
    JUnitParser.prototype.getResourcesForElement = function (element) {
        var resources = {
            attachments: [],
            fields: [],
            properties: [],
            steps: []
        };
        this.addResourcesForElementOutput(resources, element);
        this.addResourcesForElementProperties(resources, element);
        return this.transformProperties(resources);
    };
    JUnitParser.prototype.addResourcesForElementOutput = function (resources, element) {
        var outputFields = ['system-out', 'system-err'];
        for (var _i = 0, outputFields_1 = outputFields; _i < outputFields_1.length; _i++) {
            var outputField = outputFields_1[_i];
            if (outputField in element && Array.isArray(element[outputField])) {
                var output = this.convertTextElementToObject(element[outputField][0]);
                if (output instanceof Object && '#text' in output) {
                    this.addResourcesForOutput(resources, outputField, output['#text']);
                }
            }
        }
    };
    JUnitParser.prototype.addResourcesForOutput = function (resources, contentField, content) {
        var output = '';
        var lines = content.split(/\r?\n|\r|\n/g);
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            var attachmentMatch = line.match(/^\s*\[\[ATTACHMENT\|([^\]]+)\]\]/);
            if (attachmentMatch) {
                resources.attachments.push({
                    source: contentField == 'system-err' ? 'stderr' : 'stdout',
                    name: 'attachment',
                    value: attachmentMatch[1].trim()
                });
                continue;
            }
            var propertyMatchSingle = line.match(/^\s*\[\[PROPERTY\|([^=]+)=(.+)\]\]$/);
            if (propertyMatchSingle) {
                resources.properties.push({
                    source: contentField == 'system-err' ? 'stderr' : 'stdout',
                    name: propertyMatchSingle[1].trim(),
                    value: propertyMatchSingle[2].trim(),
                    isMultiline: false
                });
                continue;
            }
            var propertyMatchMulti = line.match(/^\s*\[\[PROPERTY\|(.+)\]\]$/);
            if (propertyMatchMulti) {
                var text = '';
                while (++i < lines.length) {
                    var lineInner = lines[i];
                    if (lineInner.match(/\s*\[\[\/PROPERTY\]\]/)) {
                        break;
                    }
                    text = text.concat(lineInner, '\n');
                }
                text = text.trim();
                if (text.length > 0) {
                    resources.properties.push({
                        source: contentField == 'system-err' ? 'stderr' : 'stdout',
                        name: propertyMatchMulti[1].trim(),
                        value: text,
                        isMultiline: true
                    });
                }
                continue;
            }
            output = output.concat(line, '\n');
        }
        output = output.trim();
        // Add the output as console field if any
        if (output.length > 0) {
            resources.fields.push({
                source: contentField == 'system-err' ? 'stderr' : 'stdout',
                type: 'console',
                name: contentField == 'system-err' ? 'Errors' : 'Output',
                value: output,
                isHighlight: false,
                meta: {}
            });
        }
    };
    JUnitParser.prototype.addResourcesForElementProperties = function (resources, element) {
        if (!('properties' in element)) {
            return;
        }
        if (!Array.isArray(element.properties) || element.properties.length == 0) {
            return;
        }
        var properties = element.properties[0];
        if (properties instanceof Object &&
            'property' in properties && Array.isArray(properties.property)) {
            for (var _i = 0, _a = properties.property; _i < _a.length; _i++) {
                var property = _a[_i];
                if (!(property instanceof Object) ||
                    !this.hasNonEmptyAttribute(property, '@_name')) {
                    continue;
                }
                if (this.hasNonEmptyAttribute(property, '@_value')) {
                    resources.properties.push({
                        source: 'property',
                        name: property['@_name'][0].trim(),
                        value: property['@_value'][0].trim(),
                        isMultiline: false
                    });
                }
                else {
                    var text = this.convertTextElementToObject(property);
                    if (text instanceof Object && '#text' in text) {
                        resources.properties.push({
                            source: 'property',
                            name: property['@_name'][0].trim(),
                            value: text['#text'].trim(),
                            isMultiline: true
                        });
                    }
                }
            }
        }
    };
    JUnitParser.prototype.transformProperties = function (resources) {
        var result = {
            attachments: resources.attachments,
            fields: resources.fields,
            properties: [],
            steps: []
        };
        for (var _i = 0, _a = resources.properties; _i < _a.length; _i++) {
            var property = _a[_i];
            var attachmentMatch = property.name.match(/^attachment\d*/i);
            if (attachmentMatch) {
                result.attachments.push({
                    source: property.source,
                    name: property.name,
                    value: property.value
                });
                continue;
            }
            var stepMatch = property.name.match(/^step\d*/i);
            if (stepMatch) {
                var stepStatusMatch = property.name.match(/^step\d*\[([^\]]+)\]+/i);
                if (stepStatusMatch) {
                    result.steps.push({
                        source: property.source,
                        content: property.value,
                        status: stepStatusMatch[1].trim()
                    });
                }
                else {
                    result.steps.push({
                        source: property.source,
                        content: property.value
                    });
                }
                continue;
            }
            var propertyName = property.name;
            var propertyType = 'string';
            var propertyTypeHint = this.getPropertyTypeHint(property);
            if (propertyName.startsWith(propertyTypeHint + ':')) {
                propertyName = propertyName.slice(propertyTypeHint.length + 1);
            }
            switch (propertyTypeHint) {
                case 'string':
                    propertyType = 'string';
                    break;
                case 'url':
                    if (/^http?s:\/\//.test(property.value)) {
                        propertyType = 'url';
                    }
                    break;
                case 'text':
                    propertyType = 'text';
                    break;
                case 'console':
                    propertyType = 'console';
                    break;
                case 'html':
                    propertyType = 'html';
                    break;
            }
            result.fields.push({
                source: property.source,
                type: propertyType,
                name: propertyName,
                value: property.value,
                isHighlight: false,
                meta: {}
            });
        }
        return result;
    };
    JUnitParser.prototype.getPropertyTypeHint = function (property) {
        var match = property.name.match(/^(string|url|text|console|html):.*$/);
        if (match) {
            return match[1];
        }
        else {
            if (property.isMultiline) {
                return 'text';
            }
            else {
                return 'string';
            }
        }
    };
    return JUnitParser;
}(parser_1.Parser));
exports.JUnitParser = JUnitParser;
